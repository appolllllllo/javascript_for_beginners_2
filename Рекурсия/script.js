// Работа с рекурсией в JavaScript

/* В программировании есть такое понятие, как рекурсия - это когда функция вызывает сама себя. Давайте посмотрим на примере. Выведем с помощью рекурсии числа от 1 до 10:

let i = 1;

function func(){
	console.log(i);
	i++;
	
	if (i <= 10){
		func(); // здесь функция вызывает сама себя 
	}
}
func();

Давайте обсудим, как работает этот код.

У нас есть глобальная переменная i и функция func, внутри которой в консоль выводится содержимое переменной i, а затем делается ++.

Если наша переменная i меньше или равна 10, то функция вызывается повторно. Так как переменная i - глобальная, то при каждом новом вызове функции в ней будет заданное при предыдущем вызове значение переменной i.

Получится, что функция будет вызывать сама себя до тех пор, пока i не станет больше 10.

Учтите, что в нашем случае нельзя функцию запустить без if - если это сделать, то получится бесконечный вызов функций. */

// Пример с параметром через рекурсию в JavaScript

/* Давайте, с помощью рекурсии последовательно выведем элементы массива. Пусть массив изначально передается параметрам функции:

func([1, 2, 3]);

Давайте пока без рекурсии используя метод shift выведем все элементы массива по очереди:

function func(arr) {
    console.log(arr.shift()); // выведет 1
    console.log(arr); // выведет [2, 3] - массив уменьшился

    console.log(arr.shift()); // выведет 2
    console.log(arr); // выведет [3] - массив уменьшился

    console.log(arr.shift()); // выведет 3
    console.log(arr); // выведет [] - массив пуст
}

func([1, 2, 3]);

Как вы видите, метод shift вырезает и возвращает первый элемент массива, при этом сам массив уменьшается на этот элемент.

Давайте теперь используем рекурсию:

function dunc(arr) {
    console.log(arr.shift()), arr);

    if (arr.length != 0) {
        func(arr);
    }
}

func([1, 2, 3]);

На самом деле, конечно же, проще всего перебрать элементы массива циклом. Приведенные примеры пока просто демонстрируют работу рекурсии на простых примерах (не жизненных). Более полезные примеры применения рекурсии просто более сложные, мы их разберем чуть ниже. */

/* let arr = [1, 2, 3, 4, 5];

function func(arr) {
    console.log(arr.shift(), arr);

    if (arr.length != 0) {
        func(arr);
    }
}

func(arr); */

// Сумма элементов массива при рекурсии в JavaScript

/* Давайте теперь не будем выводить элементы массива в консоль, а найдем сумму элементов этого массива:

function getSum(arr) {
    let sum = arr.shift();

    if (arr.length !== 0) {
        sum += getSum(arr);
    }

    return sum;
}

console.log(getSum([1, 2, 3])); */

/* let arr = [1, 2, 3, 4, 5];

function getSumSquare(arr) {
    let sum = arr.shift() ** 2;

    if (arr.length !== 0) {
        sum += getSumSquare(arr);
    }

    return sum;
}

console.log(getSumSquare(arr)); */

// Рекурсия и многомерные структуры в JavaScript

/* Дан массив многомерный произвольного уровня вложенности, например, такой:

let arr = [
	1,
	[
		2, 7, 8
	],
	[
		3, 4, [5, [6, 7]],
	]
];

Как вы видите, данный массив имеет сложную структуру, причем предполагается, что эта структура может быть произвольной и уровни вложенности могут быть сколь угодно глубоко.

Пусть мы хотим вывести в консоль все примитивные (то есть не массивы) элементы нашего массива. В этом случае для перебора такого массива у нас просто не получится использовать циклы, так как массив имеет неправильную структуру и неизвестный уровень вложенности.

Зато для перебора такого массива очень удобно будет использовать рекурсию.

Для начала сделаем функцию, в которую параметром будем передавать наш массив, а в функции сделаем цикл для перебора нашего массива:

function func(arr) {
    for (let elem of arr) {
        console.log(elem);
    }
}

func([1, [2, 7, 8], [3, 4, [5, [6, 7]]]]);

Сделанный нами цикл будет перебирать только элементы основного массива. To есть вначале он выведет 1, потом [2, 7, 8], а потом [3, 4, [5, [6, 7]].

Давайте теперь будем разделять в цикле элементы-примитивы и элементы-массивы:

function func(arr) {
    for(let elem of arr) {
        if (typeofelem == 'object') {
            // элемент - массив
        } else {
            // элемент - примитив
            console.log(elem);
        }
    }
}

func([1, [2, 7, 8], [3, 4, [5, [6, 7]]]]);

А теперь сделаем так, чтобы если наш элемент - массив, функция вызывала сама себя, передавая параметром этот массив:

finction func(arr) {
    for(let elem of arr) {
        if (typeofelem == 'object') {
            func(elem);
        } else {
            console.log(elem);
        }
    }
}

func([1, [2, 7, 8], [3, 4, [5, [6, 7]]]]); */

/* let obj = {a: 1, b: {c: 2, d: 3, e: 4}, f: {g: 5, j: 6, k: {l: 7, m: {n: 8, o: 9}}}};

function func(obj) {
    for (let key in obj) {
        if (typeof obj[key] == 'number') {
            console.log(obj[key]);
        } else {
            func(obj[key]);
        }
    }
}

func(obj); */

/* let arr = [1, [2, 7, 8], [3, 4, [5, [6, 7]]]];

function func(arr) {
    let newArr = [];
    for (let elem of arr) {
    if (Array.isArray(elem)) {
            newArr.push(...func(elem));
        } else {
            newArr.push(elem);
        }
    }
    return newArr;
}

console.log(func(arr)); */

// Сумма элементов массива через рекурсию в JavaScript

/* Давайте найдем сумму примитивных элементов нашего массива:

function func(arr) {
    let sum = 0;

    for (let elem of arr) {
        if (typeof elem == 'object') {
            sum += func(elem);
        } else {
            sum += elem;
        }
    }

    return sum;
}

console.log(func([1, [2, 7, 8], [3, 4, [5, [6, 7]]]])); */

/* let obj = {a: 1, b: {c: 2, d: 3, e: 4}, f: {g: 5, j: 6, k: {l: 7, m: {n: 8, o: 9}}}};

function func(obj) {
    let sum = 0;
    for (let key in obj) {
        if (typeof obj[key] == 'number') {
            sum += obj[key];
    } else {
        sum += func(obj[key]);
    }
}
    return sum;
}

console.log(func(obj)); */

/* let arr = ['a', ['b', 'c', 'd'], ['e', 'f', ['g', ['j', 'k']]]];

function func(arr) {
    let str = "";
    for (let elem of arr) {
        if (typeof elem == 'string') {
            str += elem;
        } else {
            str += func(elem);
        }
    }

    return str;
}

console.log(func(arr)); */

// Манипуляции с элементами в JavaScript

/* Давайте что-нибудь сделаем с перебираемыми элементами массива, к примеру, запишем им в конец знак '!'. В этом случае нам придется воспользоваться обычным циклом for, а не for-of, вот так:

function func(arr) {
    for (let i = 0; i < arr.length; i++) {
        if (typeof arr[i] == 'object') {
            arr[i] = func(arr[i]);
        } else {
            arr[i] = arr[i] + '!';
        }
    }

    return arr;
}

console.log(func([1, [2, 7, 8], [3, 4, [5, 6]]])); */

/* let arr = [1, [2, 7, 8], [3, 4], [5, [6, 7]]];

function func(arr) {
    for (let i = 0; i < arr.length; i++) {
        if (typeof arr[i] == 'object') {
            arr[i] = func(arr[i]);
        } else {
            arr[i] = arr[i] ** 2;
        }
    }

    return arr;
}

console.log(func(arr)); */